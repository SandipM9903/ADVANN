‚úÖ Global Exception Handling
‚úÖ Custom API Response Structure
‚úÖ Proper HTTP Status Codes
‚úÖ Clean Error Messages (Swagger will show properly)
‚úÖ Logging (SLF4J)

=====================================================================================================

Instead of random error responses, we want responses like:

‚úÖ Success Response
{
  "success": true,
  "message": "Product created successfully",
  "data": {
    "id": 1,
    "name": "Samsung Cover",
    "price": 250,
    "quantity": 20
  }
}

‚ùå Error Response
{
  "success": false,
  "message": "Product not found with id: 10",
  "data": null
}

=====================================================================================================

‚úÖ Step 1: Create Custom Response DTO

üìå Create package:

com.advann.product_service.payload

Create file: ApiResponse.java

package com.advann.product_service.payload;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}


****
What is <T> in ApiResponse<T>?

<T> is called a Generic Type Parameter in Java.

It means:
üëâ this class can hold any type of data, and that type will be decided when you use the class.

Why it is used?

Because your response data can be different for different APIs:

Sometimes data can be a Product

Sometimes it can be a List<Product>

Sometimes it can be String

Sometimes it can be null

So instead of creating separate response classes, you make one reusable class.

Example Usage
‚úÖ Returning a Product
ApiResponse<Product> response = ApiResponse.<Product>builder()
        .success(true)
        .message("Product fetched successfully")
        .data(productObject)
        .build();

Here T = Product

‚úÖ Returning a List of Products
ApiResponse<List<Product>> response = ApiResponse.<List<Product>>builder()
        .success(true)
        .message("All products fetched")
        .data(productList)
        .build();

Here T = List<Product>

‚úÖ Returning only message (no data)
ApiResponse<Void> response = ApiResponse.<Void>builder()
        .success(true)
        .message("Product deleted successfully")
        .data(null)
        .build();

Here T = Void

In your class:
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
}

So data will automatically become whatever type you pass.

Simple Meaning:

‚úÖ <T> = "Type will be decided later"

=================================================================================================================================

‚úÖ Step 2: Create Custom Exception

üìå Create package:

com.advann.product_service.exception

Create file: ResourceNotFoundException.java

package com.advann.product_service.exceptions;

public class ResourceNotFoundException extends RuntimeException{
    public ResourceNotFoundException(String message){
        super(message);
    }
}

=================================================================================================================================

‚úÖ Step 3: Create Global Exception Handler

üìå Create file: GlobalExceptionHandler.java

Path:

com.advann.product_service.exception

package com.advann.product_service.exception;

import com.advann.product_service.payload.ApiResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleResourceNotFound(ResourceNotFoundException ex) {

        ApiResponse<Object> response = ApiResponse.builder()
                .success(false)
                .message(ex.getMessage())
                .data(null)
                .build();

        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidationErrors(MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });

        ApiResponse<Map<String, String>> response = ApiResponse.<Map<String, String>>builder()
                .success(false)
                .message("Validation Failed")
                .data(errors)
                .build();

        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGenericException(Exception ex) {

        ApiResponse<Object> response = ApiResponse.builder()
                .success(false)
                .message("Something went wrong: " + ex.getMessage())
                .data(null)
                .build();

        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

=================================================================================================================================

‚úÖ Step 4: Update Service Layer to throw Exception

In ProductServiceImpl,


package com.advann.product_service.service.serviceImpl;

import com.advann.product_service.entity.Product;
import com.advann.product_service.exceptions.ResourceNotFoundException;
import com.advann.product_service.repository.ProductRepository;
import com.advann.product_service.service.services.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;

    @Override
    public Product addProduct(Product product) {
        return productRepository.save(product);
    }

    @Override
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }

    @Override
    public Product getProductById(Long id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Product not found with id: " + id
                ));
    }

    @Override
    public Product updateProduct(Long id, Product product) {
        Product existing = getProductById(id);

        existing.setName(product.getName());
        existing.setPrice(product.getPrice());
        existing.setQuantity(product.getQuantity());

        return productRepository.save(existing);
    }

    @Override
    public void deleteProduct(Long id) {
        Product existing = getProductById(id);
        productRepository.delete(existing);
    }
}


=================================================================================================================================

‚úÖ Step 5: Update Controller to Return ApiResponse

package com.advann.product_service.controller;

import com.advann.product_service.entity.Product;
import com.advann.product_service.payload.ApiResponse;
import com.advann.product_service.service.services.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @PostMapping
    public ResponseEntity<ApiResponse<Product>> addProduct(@Valid @RequestBody Product product) {
        Product saveProduct = productService.addProduct(product);
        ApiResponse<Product> response = ApiResponse.<Product>builder()
                .success(true)
                .message("Product Created Successfully")
                .data(saveProduct)
                .build();
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<ApiResponse<List<Product>>> getAllProducts() {
        List<Product> products = productService.getAllProducts();
        ApiResponse<List<Product>> response = ApiResponse.<List<Product>>builder()
                .success(true)
                .message("All Products Fetched Successfully")
                .data(products)
                .build();
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<Product>> getProductById(@PathVariable Long id) {
        Product product = productService.getProductById(id);
        ApiResponse<Product> response = ApiResponse.<Product>builder()
                .success(true)
                .message("Product Fetched With id : " + id)
                .data(product)
                .build();
        return ResponseEntity.ok(response);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<Product>> updateProduct(@PathVariable Long id, @Valid @RequestBody Product product) {
        Product updatedProduct = productService.updateProduct(id, product);
        ApiResponse<Product> response = ApiResponse.<Product>builder()
                .success(true)
                .message("Product with id : " + id + ", has been updated successfully")
                .data(product)
                .build();
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteProduct(@PathVariable Long id) {

        productService.deleteProduct(id);

        ApiResponse<String> response = ApiResponse.<String>builder()
                .success(true)
                .message("Product deleted successfully")
                .data("Product deleted with id : " + id)
                .build();

        return ResponseEntity.ok(response);
    }
}

