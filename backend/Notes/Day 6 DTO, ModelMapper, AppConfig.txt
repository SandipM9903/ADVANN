Today we will make your microservice project look production-ready.

üöÄ Day 6 Goals:

‚úÖ Add DTO Layer (Request/Response DTO)
‚úÖ Add ModelMapper (Entity ‚Üî DTO conversion)
‚úÖ Remove Entity exposure from Controller (Best Practice)
‚úÖ Add proper API structure like real companies

=========================================================================================

‚úÖ Why DTO is important?

Right now your controller is directly using:

Product entity

But in real projects we never expose database entity directly.

DTO improves:

Security

Clean API contract

Future changes without breaking API

=========================================================================================

‚úÖ Day 6 Plan (Steps)
Step 1: Create DTO package

üìå com.advann.product_service.dto

Create:

‚úÖ ProductRequestDto.java

package com.advann.product_service.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.math.BigDecimal;

@Data
public class ProductRequestDto {
    @NotBlank(message = "Product name cannot be blank")
    private String name;

    @NotNull(message = "Price cannot be null")
    //inclusive = false means the minimum value is not allowed, so the number must be strictly greater than the given value (ex: price must be > 0.0).
    @DecimalMin(value = "0.0", inclusive = false, message = "Price should be greater than 0")
    private BigDecimal price;

    @NotNull(message = "Quantity cannot be null")
    @Min(value = 1, message = "Quantity must be at least 1")
    private Integer quantity;
}


‚úÖ ProductResponseDto.java

package com.advann.product_service.dto;

import lombok.Data;

import java.math.BigDecimal;

@Data
public class ProductResponseDto {
    private Long id;
    private String name;
    private BigDecimal price;
    private Integer quantity;
}


****
‚úÖ Why we need two DTOs (Request DTO & Response DTO)?

Because input data (request) and output data (response) are not always the same.

ProductRequestDto (Client sends to backend)

Used when creating/updating product.

‚úÖ Contains only fields that user is allowed to enter:

name

price

quantity

Also contains validation annotations like @NotNull, @Min.

ProductResponseDto (Backend sends to client)

Used when returning product details.

‚úÖ Contains fields that backend wants to show:

id (generated by DB)

name

price

quantity

üî• Main Reason

üëâ Security + clean API design

Because user should not send id, but user should receive id.

=========================================================================================

‚úÖ Step 2: Add ModelMapper Dependency in pom.xml

<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>3.2.0</version>
</dependency>


ModelMapper is used to automatically convert one object to another, mainly Entity ‚Üî DTO, without writing manual mapping code.

Example (without ModelMapper)

You have to write:

ProductResponseDto dto = new ProductResponseDto();
dto.setId(product.getId());
dto.setName(product.getName());
dto.setPrice(product.getPrice());
dto.setQuantity(product.getQuantity());

With ModelMapper

Just one line:

ProductResponseDto dto = modelMapper.map(product, ProductResponseDto.class);

Why it is useful?

‚úÖ Saves time
‚úÖ Reduces boilerplate code
‚úÖ Makes service layer clean
‚úÖ Easy mapping between RequestDto ‚Üí Entity and Entity ‚Üí ResponseDto

===========================================================================================

‚úÖ Step 3: Create Config Class

üìå com.advann.product_service.config

Create: AppConfig.java

package com.advann.product_service.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public ModelMapper modelMapper(){
        return new ModelMapper();
    }
}

‚úÖ What is the use of this AppConfig?

This class is used to create and register ModelMapper as a Spring Bean, so that you can use it anywhere in your project using @Autowired.

Why needed?

If you don‚Äôt define this:

‚ùå Spring Boot will not automatically create ModelMapper object.

So you manually create it inside a config class:

@Bean
public ModelMapper modelMapper(){
    return new ModelMapper();
}

Now Spring stores it in its container.

After this you can use it anywhere like:
@Autowired
private ModelMapper modelMapper;

And then map easily:

ProductResponseDto dto = modelMapper.map(product, ProductResponseDto.class);
One line meaning:

‚úÖ AppConfig is used to define reusable objects (beans) like ModelMapper for the whole application.

===================================================================================================================================

‚úÖ DAY 6 Step 5: Update Service Implementation
Open ProductServiceImpl.java

Use this full code:

package com.advann.product_service.service.serviceImpl;

import com.advann.product_service.dto.ProductRequestDto;
import com.advann.product_service.dto.ProductResponseDto;
import com.advann.product_service.entity.Product;
import com.advann.product_service.exceptions.ResourceNotFoundException;
import com.advann.product_service.repository.ProductRepository;
import com.advann.product_service.service.services.ProductService;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;
    private final ModelMapper modelMapper;

    @Override
    public ProductResponseDto addProduct(ProductRequestDto productRequestDto) {
        Product product = modelMapper.map(productRequestDto, Product.class);
        Product saveProduct = productRepository.save(product);
        return modelMapper.map(saveProduct, ProductResponseDto.class);
    }

    @Override
    public List<ProductResponseDto> getAllProducts() {
        List<Product> products = productRepository.findAll();
        return products.stream()
                .map(product -> modelMapper.map(product, ProductResponseDto.class))
                .collect(Collectors.toList());
    }

    @Override
    public ProductResponseDto getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Product not found with id: " + id
                ));
        return modelMapper.map(product, ProductResponseDto.class);
    }

    @Override
    public ProductResponseDto updateProduct(Long id, ProductRequestDto productRequestDto) {

        Product existing = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        existing.setName(productRequestDto.getName());
        existing.setPrice(productRequestDto.getPrice());
        existing.setQuantity(productRequestDto.getQuantity());

        Product updated = productRepository.save(existing);

        return modelMapper.map(updated, ProductResponseDto.class);
    }

    @Override
    public void deleteProduct(Long id) {

        Product existing = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        productRepository.delete(existing);
    }
}


=============================================================================================================

‚úÖ DAY 6 Step 6: Update Controller

Now controller will accept DTOs and return DTOs.

Replace ProductController.java with this:

package com.advann.product_service.controller;

import com.advann.product_service.dto.ProductRequestDto;
import com.advann.product_service.dto.ProductResponseDto;
import com.advann.product_service.payload.ApiResponse;
import com.advann.product_service.service.services.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponseDto>> addProduct(@Valid @RequestBody ProductRequestDto productRequestDto) {

        ProductResponseDto savedProduct = productService.addProduct(productRequestDto);

        ApiResponse<ProductResponseDto> response = ApiResponse.<ProductResponseDto>builder()
                .success(true)
                .message("Product created successfully")
                .data(savedProduct)
                .build();

        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping
    public ResponseEntity<ApiResponse<List<ProductResponseDto>>> getAllProducts() {

        List<ProductResponseDto> products = productService.getAllProducts();

        ApiResponse<List<ProductResponseDto>> response = ApiResponse.<List<ProductResponseDto>>builder()
                .success(true)
                .message("Products fetched successfully")
                .data(products)
                .build();

        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponseDto>> getProductById(@PathVariable Long id) {

        ProductResponseDto product = productService.getProductById(id);

        ApiResponse<ProductResponseDto> response = ApiResponse.<ProductResponseDto>builder()
                .success(true)
                .message("Product fetched successfully")
                .data(product)
                .build();

        return ResponseEntity.ok(response);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<ProductResponseDto>> updateProduct(@PathVariable Long id,
                                                                         @Valid @RequestBody ProductRequestDto productRequestDto) {

        ProductResponseDto updatedProduct = productService.updateProduct(id, productRequestDto);

        ApiResponse<ProductResponseDto> response = ApiResponse.<ProductResponseDto>builder()
                .success(true)
                .message("Product updated successfully")
                .data(updatedProduct)
                .build();

        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteProduct(@PathVariable Long id) {

        productService.deleteProduct(id);

        ApiResponse<String> response = ApiResponse.<String>builder()
                .success(true)
                .message("Product deleted successfully")
                .data("Product deleted with id : " + id)
                .build();

        return ResponseEntity.ok(response);
    }
}
